import { CreateUserUseCase } from "../CreateUserUseCase";
import { PostgresUsersRepository } from "../../../../repositories/implementations/PostgresUsersRepository";
import bcrypt from "bcrypt";

// Mocking the repository
jest.mock(
	"../../../../repositories/implementations/PostgresUsersRepository.ts"
);

// Mock bcrypt.hash explicitly with a return value
jest.mock("bcrypt", () => ({
	...jest.requireActual("bcrypt"),
	hash: jest.fn().mockResolvedValue("hashed_password"), // Set the return value for hash
}));

describe("CreateUserUseCase (Unit Tests)", () => {
	let createUserUseCase: CreateUserUseCase;
	let mockPostgresUsersRepository: jest.Mocked<PostgresUsersRepository>;

	// Runs before each test to ensure a clean, isolated environment
	beforeEach(() => {
		// Creating a mocked instance of the repository
		mockPostgresUsersRepository =
			new PostgresUsersRepository() as jest.Mocked<PostgresUsersRepository>;

		// Mocking the 'save' function of the repository
		mockPostgresUsersRepository.save = jest.fn().mockResolvedValue({
			id: "1", // Simulated user ID
			name: "user",
			email: "user@user.com",
			password: "hashed_password", // Normally this would be a hashed password generated by bcrypt
		});

		// Mocking the 'findByEmail' function to return null by default
		mockPostgresUsersRepository.findByEmail = jest
			.fn()
			.mockResolvedValue(null);

		// Instantiating the use case with the mocked repository
		createUserUseCase = new CreateUserUseCase(mockPostgresUsersRepository);
	});

	it("should save the user with the provided information", async () => {
		// Input data
		const name = "user";
		const email = "user@user.com";
		const password = "password";

		// Executing the use case
		const userCreated = await createUserUseCase.execute({
			name,
			email,
			password,
		});

		// Verifying if the user was created with the correct data
		expect(userCreated.name).toBe(name);
		expect(userCreated.email).toBe(email);

		// Verifying if created_at and updated_at are present and in the correct format
		expect(userCreated.created_at).toBeDefined();
		expect(userCreated.updated_at).toBeDefined();
		expect(new Date(userCreated.created_at).getTime()).toBeGreaterThan(0);
		expect(new Date(userCreated.updated_at).getTime()).toBeGreaterThan(0);

		// Ensuring the repository's `save` method was called with the correct arguments
		expect(mockPostgresUsersRepository.save).toHaveBeenCalledWith(
			expect.objectContaining({
				name,
				email,
				password: "hashed_password", // Ensuring that the hashed password is passed to save
			})
		);
	});

	it("should throw an error if the user already exists", async () => {
		// Mocking the repository's findByEmail method to simulate an existing user
		mockPostgresUsersRepository.findByEmail = jest.fn().mockResolvedValue({
			id: "1",
			name: "user",
			email: "user@user.com",
			password: "hashed_password",
		});

		// Ensuring the use case throws an error if the email already exists
		await expect(
			createUserUseCase.execute({
				name: "user",
				email: "user@user.com",
				password: "password",
			})
		).rejects.toThrow("The user already exists");

		// Verifying if findByEmail was called with the correct email
		expect(mockPostgresUsersRepository.findByEmail).toHaveBeenCalledWith(
			"user@user.com"
		);
	});

	it("should throw an error if the repository fails to save the user", async () => {
		// Mocking a failure in the repository's save method
		mockPostgresUsersRepository.save.mockRejectedValue(
			new Error("Failed to save")
		);

		// Ensuring the use case throws an error when the repository fails
		await expect(
			createUserUseCase.execute({
				name: "user",
				email: "user@user.com",
				password: "password",
			})
		).rejects.toThrow("Failed to save");
	});

	it("should hash the password before saving", async () => {
		// Ensuring the hash method was called with the correct parameters
		await createUserUseCase.execute({
			name: "user",
			email: "user@user.com",
			password: "password",
		});

		// Ensuring the hash method was called with the correct parameters
		expect(bcrypt.hash).toHaveBeenCalledWith(
			"password",
			expect.any(Number)
		);
	});
});
